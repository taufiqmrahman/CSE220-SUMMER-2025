//Assignment 02
//task1
 public static String checkSimilar( Node building1, Node building2 ){
        
        Node temp = building1;
        Node temp2 = building2;
        int count =0;
        int count2 =0;
        boolean check = true;
        while(temp!=null){
            count++;
            temp=temp.next;
        }
        while(temp2!=null){
            count2++;
            temp2 = temp2.next;
        }
        if(count != count2){
            return "Not Similar";
        }
        else{
            temp = building1;
            temp2 = building2;
            while(temp!=null && temp2!=null){
                if(!((String)temp.elem).equals((String)temp2.elem)){
                    check = false;
                    break;
                }
                temp=temp.next;
                temp2 = temp2.next;
            }
            if(check==true){
                return "Similar";
            }
            else{
                return "Not Similar";
            }
        }


    }

//task2
public static int sumDist(Node head, Integer[] distArr) {
        Node temp = head;
        int length = distArr.length;
        int sum =0; 
        for(int i =0; i<length;i++){
            sum += elemAt(head,distArr[i]);
            temp = temp.next;
        }
        return sum;
    }
    public static int elemAt(Node head,int idx){
        Node temp = head;
        int count = 0;
        while(temp!=null){
            if (count==idx){
                return (int)temp.elem;
            }
            count++;
            temp=temp.next;
        }
        return 0;
    }

//task3
public static Node alternateMerge( Node head1, Node head2 ){

        Node temp = head1;
        Node temp2 = head2;
        Node next1;
        Node next2;

        while (temp != null && temp2 != null) {
            next1 = temp.next;
            next2 = temp2.next;
            temp.next = temp2;
            temp2.next = next1;
            temp = next1;
            temp2 = next2;
        }
        return head1;
    }

//task4
public static Node idGenerator(Node head1, Node head2, Node head3) {
    
        Node temp = head1;
        Node newH = new Node (temp.elem);
        temp = temp.next;
        while(temp!=null){
            Node newN = new Node(temp.elem);
            newN.next = newH;
            newH = newN;
            temp = temp.next;
        }
        int sum =0;
        for(int i=0; i<length(head2); i++){
            sum = elemAt(head2, i) + elemAt(head3, i);
            Node temp1 = newH;
            while(temp1.next!=null){
                temp1 = temp1.next;
            }
            if(sum>=10){
                sum = sum % 10;
            }
            Node newN = new Node(sum);
            temp1.next = newN;
            temp1 = newN;

        }

        return newH; 
    }
    static int elemAt(Node head, int idx) {
        Node temp = head;
        int count = 0;
        while (temp != null) {
            if (count == idx) {
                return (int)temp.elem; 
            }
            temp = temp.next;
            count++;
        }
        return 0; 
    }
    static int length(Node head) {
        Node temp = head;
        int count = 0;
        while (temp != null) {
            count++;
            temp = temp.next;
        }
        return count;
    }

//Assignment 03
//task5
public static void sumOddAppend(Node dh) {
        Node temp = dh.next;
        Node temp2 = dh;
        int sum =0;
        while(temp.next!=dh){
            if((int)temp.elem%2 != 0){
                sum += (int)temp.elem;
                Node temp3 = temp.next;
                Node temp4= temp;
                temp2.next = temp3;
                temp2 = temp2.next;
                temp = temp.next;
                temp4.next = null;

            }
        }
        Node newN = new Node(sum);
        temp.next = newN;
        newN.next = dh;
    }

//task6
public static void pairJoin(DNode dh1, DNode dh2) {
        DNode temp = dh1;
        DNode current1 = dh1.next;
        DNode current2 = dh2.next;

        while(temp != null && current1 != null && current2 != null){
            temp.next = current1;
            current1.prev = temp;
            temp = current1;
            current1 = current1.next;
            temp.next = current2;
            current2.prev = temp;
            temp=current2;
            current2 = current2.next;
        }
        temp.next = dh1;
        dh1.prev = temp;
    }

//task7
public static void rangeMove(DNode dh, int start, int end) {
        DNode curr = dh.next;
        DNode last = dh.prev; 
        while (curr != dh) {
            DNode nextNode = curr.next; 
            int val = (int) curr.elem;
            if (val >= start && val <= end ) {
                curr.prev.next = curr.next;
                curr.next.prev = curr.prev;
                DNode tail = dh.prev;
                curr.prev = tail;
                curr.next = dh;
                tail.next = curr;
                dh.prev = curr;
            }
            if (curr == last) {
                break;
            }
            curr = nextNode;
        }
    } 
